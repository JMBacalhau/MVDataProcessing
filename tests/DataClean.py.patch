# Patch generated by Pyment v0.3.3

--- a/DataClean.py
+++ b/DataClean.py
@@ -29,11 +29,16 @@
 
 
 def DataClean(x_in,start_date_dt: datetime,end_date_dt,sample_freq = 5,sample_time_base = 'm'):        
-    '''
-    np.timedelta64 -> (D)ay, (M)onth, (Y)ear, (h)ours, (m)inutes, or (s)econds.
+    """np.timedelta64 -> (D)ay, (M)onth, (Y)ear, (h)ours, (m)inutes, or (s)econds.
     x_in = dummy.copy(deep=True)
-    
-    '''
+
+    :param x_in: 
+    :param start_date_dt: datetime: 
+    :param end_date_dt: 
+    :param sample_freq:  (Default value = 5)
+    :param sample_time_base:  (Default value = 'm')
+
+    """
     
     added_dic = {'s':'ms','m':'s','h':'m','D':'h','M':'D','Y':'M'}
     floor_dic = {'s':'S','m':'T','h':'H','D':'D','M':'M','Y':'Y'}    
@@ -146,6 +151,12 @@
     return Y
 
 def IntegrateHour(Y,sample_freq = 5):
+    """
+
+    :param Y: 
+    :param sample_freq:  (Default value = 5)
+
+    """
     
     time_vet_stamp = Y.index[np.arange(0,len(Y.index),int(60/sample_freq))]    
     Y = Y.groupby([Y.index.year,Y.index.month,Y.index.day,Y.index.hour]).mean() 
@@ -156,12 +167,22 @@
     return Y
 
 def Correlation(X):
+    """
+
+    :param X: 
+
+    """
     
     corr_value = X.corr()[X.corr()!=1].mean().mean()
     
     return corr_value
     
 def DayPeriodMapper(hour):
+    """
+
+    :param hour: 
+
+    """
     return (
         0 if 0 <= hour < 6
         else
@@ -173,6 +194,13 @@
     )
 
 def PhaseProportonInput(X,sample_freq = 5,threshold_accept = 0.75):
+    """
+
+    :param X: 
+    :param sample_freq:  (Default value = 5)
+    :param threshold_accept:  (Default value = 0.75)
+
+    """
     
     Y = X.copy(deep=True)
     
@@ -217,6 +245,14 @@
     return Y
 
 def ReturnOnlyValidDays(x_in,sample_freq = 5,threshold_accept = 1.0,sample_time_base = 'm'):
+    """
+
+    :param x_in: 
+    :param sample_freq:  (Default value = 5)
+    :param threshold_accept:  (Default value = 1.0)
+    :param sample_time_base:  (Default value = 'm')
+
+    """
     
     X = x_in.copy(deep=True)
     
@@ -250,6 +286,16 @@
     return X,df_count
 
 def GetDayMaxMin(x_in,start_date_dt,end_date_dt,sample_freq = 5,threshold_accept = 1.0,exe_param='max'):
+    """
+
+    :param x_in: 
+    :param start_date_dt: 
+    :param end_date_dt: 
+    :param sample_freq:  (Default value = 5)
+    :param threshold_accept:  (Default value = 1.0)
+    :param exe_param:  (Default value = 'max')
+
+    """
     
     X = x_in.copy(deep=True)
     
@@ -272,6 +318,15 @@
     return Y
 
 def GetWeekDayCurve(x_in,sample_freq = 5,threshold_accept = 1.0,min_sample_per_day = 3,min_sample_per_workday = 9):
+    """
+
+    :param x_in: 
+    :param sample_freq:  (Default value = 5)
+    :param threshold_accept:  (Default value = 1.0)
+    :param min_sample_per_day:  (Default value = 3)
+    :param min_sample_per_workday:  (Default value = 9)
+
+    """
     
     #x_in = dummy.copy(deep=True)
     
@@ -331,6 +386,19 @@
     return Y
         
 def SimpleProcess(X,start_date_dt,end_date_dt,sample_freq = 5,pre_interpol=False,pos_interpol=False,prop_phases=False,integrate=False,interpol_integrate=False):    
+    """
+
+    :param X: 
+    :param start_date_dt: 
+    :param end_date_dt: 
+    :param sample_freq:  (Default value = 5)
+    :param pre_interpol:  (Default value = False)
+    :param pos_interpol:  (Default value = False)
+    :param prop_phases:  (Default value = False)
+    :param integrate:  (Default value = False)
+    :param interpol_integrate:  (Default value = False)
+
+    """
         
     #ORGANIZE->INTERPOLATE->PHASE_PROPORTION->INTERPOLATE->INTEGRATE->INTERPOLATE
     
@@ -357,6 +425,12 @@
     return Y
 
 def RemovePeriod(x_in,df_remove):
+    """
+
+    :param x_in: 
+    :param df_remove: 
+
+    """
     
     Y = x_in.copy(deep=True)    
      
@@ -366,6 +440,12 @@
     return Y
 
 def SavePeriod(x_in,df_save):    
+    """
+
+    :param x_in: 
+    :param df_save: 
+
+    """
     
     Y = x_in.copy(deep=True)
     mark_index_not = x_in.index    
@@ -377,6 +457,14 @@
     return Y,mark_index_not
 
 def RemoveOutliersHardThreshold(x_in,hard_max=False,hard_min=False,df_avoid_periods = pd.DataFrame([])):
+    """
+
+    :param x_in: 
+    :param hard_max:  (Default value = False)
+    :param hard_min:  (Default value = False)
+    :param df_avoid_periods:  (Default value = pd.DataFrame([]))
+
+    """
         
     Y = x_in.copy(deep=True)    
     
@@ -390,6 +478,13 @@
     return Y
 
 def RemoveOutliersHistoGram(x_in,df_avoid_periods = pd.DataFrame([]),min_number_of_samples_limit=12):
+    """
+
+    :param x_in: 
+    :param df_avoid_periods:  (Default value = pd.DataFrame([]))
+    :param min_number_of_samples_limit:  (Default value = 12)
+
+    """
     
     Y = x_in.copy(deep=True)
     
@@ -417,14 +512,16 @@
 
 
 def CalcUnbalance(x_in):
-    '''
-    Calculates the unbalance between phases for every timestamp.
-    
-    Equation:        
+    """Calculates the unbalance between phases for every timestamp.
+    
+    Equation:
         Y = (MAX-MEAN)/MEAN
     
     Ref.: Derating of induction motors operating with a combination of unbalanced voltages and over or undervoltages
-    '''
+
+    :param x_in: 
+
+    """
     
     Y = pd.DataFrame([],index=x_in.index)    
     
@@ -434,6 +531,13 @@
 
 #TERMINAR DE IMPLEMENTAR
 def RemoveOutliersQuantile(x_in,col_names = [],drop=False):
+    """
+
+    :param x_in: 
+    :param col_names:  (Default value = [])
+    :param drop:  (Default value = False)
+
+    """
     
     Y = x_in.copy(deep=True)
     
@@ -456,6 +560,17 @@
 
 
 def RemoveOutliersAEAMAD(x_in,df_avoid_periods = pd.DataFrame([]),len_mov_avg = 4*12,std_def = 2,min_var_def = 0.5,allow_negatives=False,plot=False):
+    """
+
+    :param x_in: 
+    :param df_avoid_periods:  (Default value = pd.DataFrame([]))
+    :param len_mov_avg:  (Default value = 4*12)
+    :param std_:  (Default value = 2)
+    :param min_var_:  (Default value = 0.5)
+    :param allow_negatives:  (Default value = False)
+    :param plot:  (Default value = False)
+
+    """
     
     x_in = dummy.copy(deep=True)      
     x_in.iloc[35000:38000,:] = np.nan
